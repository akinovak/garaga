use array::ArrayTrait;

const STARK_MINUS_1_HALF: u256 =
    1809251394333065606848661391547535052811553607665798349986546028067936010240;


// From a 128 bit scalar, decomposes it into base (-3) such that
// scalar = sum(digits[i] * (-3)^i for i in [0, 81])
// scalar = sum_p - sum_n
// Where sum_p = sum(digits[i] * (-3)^i for i in [0, 81] if digits[i]==1)
// And sum_n = sum(digits[i] * (-3)^i for i in [0, 81] if digits[i]==-1)
// Returns (abs(sum_p), abs(sum_n), p_sign, n_sign)
pub fn scalar_to_base_neg3_le(scalar: u128) -> (felt252, felt252, felt252, felt252) {
    let MINUS3_POWERS: Span<felt252> = array![
        1,
        3618502788666131213697322783095070105623107215331596699973092056135872020478,
        9,
        3618502788666131213697322783095070105623107215331596699973092056135872020454,
        81,
        3618502788666131213697322783095070105623107215331596699973092056135872020238,
        729,
        3618502788666131213697322783095070105623107215331596699973092056135872018294,
        6561,
        3618502788666131213697322783095070105623107215331596699973092056135872000798,
        59049,
        3618502788666131213697322783095070105623107215331596699973092056135871843334,
        531441,
        3618502788666131213697322783095070105623107215331596699973092056135870426158,
        4782969,
        3618502788666131213697322783095070105623107215331596699973092056135857671574,
        43046721,
        3618502788666131213697322783095070105623107215331596699973092056135742880318,
        387420489,
        3618502788666131213697322783095070105623107215331596699973092056134709759014,
        3486784401,
        3618502788666131213697322783095070105623107215331596699973092056125411667278,
        31381059609,
        3618502788666131213697322783095070105623107215331596699973092056041728841654,
        282429536481,
        3618502788666131213697322783095070105623107215331596699973092055288583411038,
        2541865828329,
        3618502788666131213697322783095070105623107215331596699973092048510274535494,
        22876792454961,
        3618502788666131213697322783095070105623107215331596699973091987505494655598,
        205891132094649,
        3618502788666131213697322783095070105623107215331596699973091438462475736534,
        1853020188851841,
        3618502788666131213697322783095070105623107215331596699973086497075305464958,
        16677181699666569,
        3618502788666131213697322783095070105623107215331596699973042024590773020774,
        150094635296999121,
        3618502788666131213697322783095070105623107215331596699972641772229981023118,
        1350851717672992089,
        3618502788666131213697322783095070105623107215331596699969039500982853044214,
        12157665459056928801,
        3618502788666131213697322783095070105623107215331596699936619059758701234078,
        109418989131512359209,
        3618502788666131213697322783095070105623107215331596699644835088741334942854,
        984770902183611232881,
        3618502788666131213697322783095070105623107215331596697018779349585038321838,
        8862938119652501095929,
        3618502788666131213697322783095070105623107215331596673384277697178368732694,
        79766443076872509863361,
        3618502788666131213697322783095070105623107215331596460673762825518342430398,
        717897987691852588770249,
        3618502788666131213697322783095070105623107215331594546279128980578105709734,
        6461081889226673298932241,
        3618502788666131213697322783095070105623107215331577316727424376115975223758,
        58149737003040059690390169,
        3618502788666131213697322783095070105623107215331422250762082935956800849974,
        523347633027360537213511521,
        3618502788666131213697322783095070105623107215330026657074009974524231485918,
        4710128697246244834921603689,
        3618502788666131213697322783095070105623107215317466313881353321631107209414,
        42391158275216203514294433201,
        3618502788666131213697322783095070105623107215204423225147443445592988720878,
        381520424476945831628649898809,
        3618502788666131213697322783095070105623107214187035426542254561249922324054,
        3433683820292512484657849089281,
        3618502788666131213697322783095070105623107205030545239095554602162324752638,
        30903154382632612361920641803529,
        3618502788666131213697322783095070105623107122622133552075254970373946609894,
        278128389443693511257285776231761,
        3618502788666131213697322783095070105623106380946428368892558284278543325198,
        2503155504993241601315571986085849,
        3618502788666131213697322783095070105623099705865081720248288109419913762934,
        22528399544939174411840147874772641,
        3618502788666131213697322783095070105623039630132961882449856535692247702558,
        202755595904452569706561330872953769,
        3618502788666131213697322783095070105622498948543883342263972372143253159174,
        1824800363140073127359051977856583921,
        3618502788666131213697322783095070105617632814242176480591014900202302268718,
        16423203268260658146231467800709255289,
        3618502788666131213697322783095070105573837605526814725534397652733744254614,
        147808829414345923316083210206383297601,
        3618502788666131213697322783095070105179680727088558930024842425516722127678
    ]
        .span();

    let digits: Span<felt252> = neg_3_base_le(scalar).span();

    let digits_len = digits.len();

    let mut sum_p = 0;
    let mut sum_n = 0;

    //let mut base_power = 1;
    let mut i = digits_len;

    //implementation like this to run in O(n) time complexity, only computing each power of -3 once
    while i != 0 {
        let digit = digits.at(digits_len - i);
        let base_power = *MINUS3_POWERS.at(digits_len - i);

        if *digit != 0 {
            if *digit == 1 {
                sum_p += base_power;
            } else {
                sum_n += base_power;
            }
        }

        //base_power = base_power * (-3);
        i -= 1;
    };

    return (sum_p, sum_n, sign(sum_p), sign(sum_n));
}

fn sign(num: felt252) -> felt252 {
    if num.into() <= STARK_MINUS_1_HALF {
        return 1;
    } else {
        return -1;
    }
}

// Decomposes a scalar into base -3 representation.
// :param scalar: The integer to be decomposed.
// :return: A list of coefficients in base -3 representation. (Least significant bit first),
// with digits [-1, 0, 1] such that scalar = sum((-3) ** i * d for (i, d) in enumerate(digits))
pub fn neg_3_base_le(scalar: u128) -> Array<felt252> {
    let mut digits: Array<felt252> = ArrayTrait::new();

    if scalar == 0 {
        digits.append(0);
        return digits;
    }

    let mut scalar: u128 = scalar;

    let mut scalar_negative: bool = false;

    while scalar != 0 {
        let (q, r) = core::traits::DivRem::div_rem(scalar, 3);

        if r == 2 {
            if scalar_negative {
                scalar = q + 1;
                digits.append(1);
            } else {
                scalar = q + 1;
                digits.append(-1);
            }
        } else {
            if scalar_negative {
                scalar = q;
                digits.append(-r.into());
            } else {
                scalar = q;
                digits.append(r.into());
            }
        }
        scalar_negative = !scalar_negative;
    };

    return digits;
}
